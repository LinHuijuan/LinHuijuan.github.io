(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{904:function(v,_,n){"use strict";n.r(_);var t=n(17),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,n=v._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[n("ul",[n("li",[v._v("剩余参数")])]),v._v(" "),n("p",[v._v("function push(array: any[], ...items: any[]) {")]),v._v(" "),n("p",[v._v("​    items.forEach(function(item) {")]),v._v(" "),n("p",[v._v("​        array.push(item);")]),v._v(" "),n("p",[v._v("​    });")]),v._v(" "),n("p",[v._v("}")]),v._v(" "),n("p",[v._v("let a = [];")]),v._v(" "),n("p",[v._v("push(a, 1, 2, 3);")]),v._v(" "),n("ul",[n("li",[v._v("函数重载")])]),v._v(" "),n("p",[v._v("type Types = number | string")]),v._v(" "),n("p",[v._v("function add(a:number,b:number):number;")]),v._v(" "),n("p",[v._v("function add(a: string, b: string): string;")]),v._v(" "),n("p",[v._v("function add(a: string, b: number): string;")]),v._v(" "),n("p",[v._v("function add(a: number, b: string): string;")]),v._v(" "),n("p",[v._v("function add(a:Types, b:Types) {")]),v._v(" "),n("p",[v._v("if (typeof a === 'string' || typeof b === 'string') {")]),v._v(" "),n("p",[v._v("​    return a.toString() + b.toString();")]),v._v(" "),n("p",[v._v("}")]),v._v(" "),n("p",[v._v("return a + b;")]),v._v(" "),n("p",[v._v("}")]),v._v(" "),n("p",[v._v("const result = add('Semlinker', ' Kakuqo');")]),v._v(" "),n("p",[v._v("result.split(' ');")]),v._v(" "),n("ul",[n("li",[v._v("关于any")])]),v._v(" "),n("p",[v._v("在any上访问任何属性都是允许的,也允许调用任何方法.")]),v._v(" "),n("p",[v._v("​    变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型，例如 let a;")]),v._v(" "),n("p",[v._v("​    如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 "),n("code",[v._v("any")]),v._v(" 类型而完全不被类型检查")]),v._v(" "),n("ul",[n("li",[n("code",[v._v("unknown")]),v._v("与"),n("code",[v._v("any")]),v._v("的最大区别是： 任何类型的值可以赋值给"),n("code",[v._v("any")]),v._v("，同时"),n("code",[v._v("any")]),v._v("类型的值也可以赋值给任何类型。"),n("code",[v._v("unknown")]),v._v(" 任何类型的值都可以赋值给它，但它只能赋值给"),n("code",[v._v("unknown")]),v._v("和"),n("code",[v._v("any")])])]),v._v(" "),n("p",[v._v("这种机制起到了很强的预防性，更安全，这就要求我们必须缩小类型，我们可以使用"),n("code",[v._v("typeof")]),v._v("、"),n("code",[v._v("类型断言")]),v._v("等方式来缩小未知范围")]),v._v(" "),n("ul",[n("li",[v._v("首字母大写的 Number、String、Boolean、Symbol 类型，后者是相应原始类型的"),n("code",[v._v("包装对象")]),v._v("，姑且把它们称之为对象类型。")])]),v._v(" "),n("p",[v._v("不要使用对象类型来注解值的类型，因为这没有任何意义。")]),v._v(" "),n("ul",[n("li",[n("p",[v._v("{}、大 Object 是比小 object 更宽泛的类型（least specific），{} 和大 Object 可以互相代替，用来表示原始类型（null、undefined 除外）和非原始类型；而小 object 则表示非原始类型。")])]),v._v(" "),n("li")])])}),[],!1,null,null,null);_.default=e.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{600:function(a,t,r){a.exports=r.p+"assets/img/data-structure.3e5bd440.jpg"},601:function(a,t,r){a.exports=r.p+"assets/img/tree-height.0450697b.jpg"},708:function(a,t,r){"use strict";r.r(t);var _=r(17),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"数据结构-data-structure"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-data-structure"}},[a._v("#")]),a._v(" 数据结构(data structure)")]),a._v(" "),_("p",[a._v("[TOC]")]),a._v(" "),_("ul",[_("li",[a._v("定义：指所有数据元素以及数据元素之间的关系，可以看作是相互之间存在着某种特定关系的数据元素的集合。（带结构的数据元素的集合）")])]),a._v(" "),_("p",[_("img",{attrs:{src:r(600),alt:"data-structure"}})]),a._v(" "),_("h2",{attrs:{id:"一、线性表-linear-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、线性表-linear-list"}},[a._v("#")]),a._v(" 一、线性表(linear list)")]),a._v(" "),_("ul",[_("li",[a._v("定义：具有相同特性的数据元素的一个有限序列。")])]),a._v(" "),_("h3",{attrs:{id:"_1-1-顺序表-sequential-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-顺序表-sequential-list"}},[a._v("#")]),a._v(" 1.1 顺序表(sequential list)")]),a._v(" "),_("ul",[_("li",[a._v("定义：线性表的顺序存储结构。")])]),a._v(" "),_("h3",{attrs:{id:"_1-2-链表-linked-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-链表-linked-list"}},[a._v("#")]),a._v(" 1.2 链表(linked list)")]),a._v(" "),_("blockquote",[_("p",[a._v("指针和引用都是一样的东西，都是存储所指对象的内存地址。")]),a._v(" "),_("p",[a._v("将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。")]),a._v(" "),_("p",[a._v("记住一句话：s->next = p->next(s的指针指向p的指针指向的结点)")])]),a._v(" "),_("ul",[_("li",[a._v("定义：线性表的链式存储结构。")]),a._v(" "),_("li",[a._v("优势：对症下药，只对相关元素进行操作。\n运用js的Arrary类方法可以方便栈和队列的实现，但实际上对元素的移除或添加，都是牵一发而动全身，操作成本较高。\n而链表只需要改变相关元素的指针指向。")]),a._v(" "),_("li",[a._v("待学习：https://juejin.im/post/58287452570c3500587642b6")])]),a._v(" "),_("h4",{attrs:{id:"_1-2-1-单链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-单链表"}},[a._v("#")]),a._v(" 1.2.1 单链表")]),a._v(" "),_("h4",{attrs:{id:"_1-2-2-双链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-双链表"}},[a._v("#")]),a._v(" 1.2.2 双链表")]),a._v(" "),_("h4",{attrs:{id:"_1-2-3-循环链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-循环链表"}},[a._v("#")]),a._v(" 1.2.3 循环链表")]),a._v(" "),_("h3",{attrs:{id:"_1-3-有序表-ordered-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-有序表-ordered-list"}},[a._v("#")]),a._v(" 1.3 有序表(ordered list)")]),a._v(" "),_("ul",[_("li",[a._v("定义：所有元素以递增或递减方式有序排列的线性表。")])]),a._v(" "),_("h2",{attrs:{id:"二、栈-stack"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、栈-stack"}},[a._v("#")]),a._v(" 二、栈(stack)")]),a._v(" "),_("ul",[_("li",[a._v("定义：一种只能在一端进行插入或删除操作的线性表。(先进后出)")])]),a._v(" "),_("h3",{attrs:{id:"_2-1-顺序栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-顺序栈"}},[a._v("#")]),a._v(" 2.1 顺序栈")]),a._v(" "),_("h3",{attrs:{id:"_2-2-链式栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-链式栈"}},[a._v("#")]),a._v(" 2.2 链式栈")]),a._v(" "),_("h2",{attrs:{id:"三、队列-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、队列-queue"}},[a._v("#")]),a._v(" 三、队列(queue)")]),a._v(" "),_("ul",[_("li",[a._v("定义：一种仅在一端进行插入，而在另一端进行删除操作的线性表，也称队。(先进先出)")])]),a._v(" "),_("h3",{attrs:{id:"_3-1-顺序队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-顺序队列"}},[a._v("#")]),a._v(" 3.1 顺序队列")]),a._v(" "),_("h3",{attrs:{id:"_3-2-链式队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-链式队列"}},[a._v("#")]),a._v(" 3.2 链式队列")]),a._v(" "),_("h3",{attrs:{id:"_3-3-双端队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-双端队列"}},[a._v("#")]),a._v(" 3.3 双端队列")]),a._v(" "),_("h2",{attrs:{id:"四、串-string"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、串-string"}},[a._v("#")]),a._v(" 四、串(string)")]),a._v(" "),_("ul",[_("li",[a._v("定义：由零个或多个字符组成的有限序列。")])]),a._v(" "),_("h3",{attrs:{id:"_4-1-顺序串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-顺序串"}},[a._v("#")]),a._v(" 4.1 顺序串")]),a._v(" "),_("h3",{attrs:{id:"_4-2-链串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-链串"}},[a._v("#")]),a._v(" 4.2 链串")]),a._v(" "),_("h2",{attrs:{id:"五、数组-array"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、数组-array"}},[a._v("#")]),a._v(" 五、数组(array)")]),a._v(" "),_("ul",[_("li",[a._v("定义：具有相同数据类型的数据元素的有限序列。")])]),a._v(" "),_("h3",{attrs:{id:"_5-1-稀疏矩阵-sparse-matrix"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-稀疏矩阵-sparse-matrix"}},[a._v("#")]),a._v(" 5.1 稀疏矩阵(sparse matrix)")]),a._v(" "),_("ul",[_("li",[a._v("定义：非零元素个数相对于矩阵元素的总个数非常小的阶数较大的矩阵。")])]),a._v(" "),_("h2",{attrs:{id:"六、广义表-generalized-table"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、广义表-generalized-table"}},[a._v("#")]),a._v(" 六、广义表(generalized table)")]),a._v(" "),_("ul",[_("li",[a._v("定义：线性表的推广，是有限个元素的推广，容许元素具有其自身结构。")])]),a._v(" "),_("h2",{attrs:{id:"七、树-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七、树-tree"}},[a._v("#")]),a._v(" 七、树(tree)")]),a._v(" "),_("ul",[_("li",[a._v("定义：由n(n≥0)个结点(或元素)组成的有限集合。")]),a._v(" "),_("li",[a._v("待学习：https://juejin.im/post/587cccca8d6d810058d377e2")]),a._v(" "),_("li",[a._v("一些相关概念\n"),_("ul",[_("li",[a._v("节点的"),_("strong",[a._v("高度")]),a._v(" = 节点到叶子节点的最长路径（边数）")]),a._v(" "),_("li",[a._v("节点的"),_("strong",[a._v("深度")]),a._v(" = 根节点到这个节点所经历的边的个数")]),a._v(" "),_("li",[a._v("节点的"),_("strong",[a._v("层数")]),a._v(" = 节点的深度 + 1")]),a._v(" "),_("li",[a._v("树的"),_("strong",[a._v("高度")]),a._v(" = 根节点的高度")])])])]),a._v(" "),_("p",[_("img",{attrs:{src:r(601),alt:"tree-height"}})]),a._v(" "),_("h3",{attrs:{id:"_7-1-二叉树-binary-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-二叉树-binary-tree"}},[a._v("#")]),a._v(" 7.1 二叉树(binary tree)")]),a._v(" "),_("ul",[_("li",[a._v("定义：一个有限的结点集合，这个集合或者为空，或者由一个根节点和两颗互不相交的称为左子树(left subtree)和右子树(right suntree)的二叉树组成。")])]),a._v(" "),_("h4",{attrs:{id:"_7-1-1-一些树的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-1-一些树的概念"}},[a._v("#")]),a._v(" 7.1.1 一些树的概念")]),a._v(" "),_("ul",[_("li",[a._v("满二叉树\n"),_("ul",[_("li",[a._v("除叶子节点外，每个节点都有左右两个子节点。")])])]),a._v(" "),_("li",[a._v("完全二叉树\n"),_("ul",[_("li",[a._v("叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。")])])])]),a._v(" "),_("h3",{attrs:{id:"_7-2-线索二叉树-threaded-binary-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-线索二叉树-threaded-binary-tree"}},[a._v("#")]),a._v(" 7.2 线索二叉树(threaded binary-tree)")]),a._v(" "),_("ul",[_("li",[a._v("定义：线索化的二叉树。")])]),a._v(" "),_("h3",{attrs:{id:"_7-3-哈夫曼树-huffman-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-哈夫曼树-huffman-tree"}},[a._v("#")]),a._v(" 7.3 哈夫曼树(Huffman tree)")]),a._v(" "),_("ul",[_("li",[a._v("定义：在n个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树，也称最优二叉树。")])]),a._v(" "),_("h3",{attrs:{id:"_7-4-二叉查找树-binary-search-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-二叉查找树-binary-search-tree"}},[a._v("#")]),a._v(" 7.4 二叉查找树（Binary Search Tree）")]),a._v(" "),_("h4",{attrs:{id:"_7-4-1-查找"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-1-查找"}},[a._v("#")]),a._v(" 7.4.1 查找")]),a._v(" "),_("ol",[_("li",[a._v("先取根节点，如果它等于我们要查找的数据，就返回。")]),a._v(" "),_("li",[a._v("如果要查找的数据比根节点的值小，那就在左子数中递归查找。")]),a._v(" "),_("li",[a._v("如果要查找的数据比根节点的值大，那就再右子树中递归查找。")])]),a._v(" "),_("h4",{attrs:{id:"_7-4-2-插入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-2-插入"}},[a._v("#")]),a._v(" 7.4.2 插入")]),a._v(" "),_("ol",[_("li",[a._v("只需要从根节点开始，依次比较要插入的数据和节点的大小关系。")]),a._v(" "),_("li",[a._v("如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。")]),a._v(" "),_("li",[a._v("同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。")])]),a._v(" "),_("h4",{attrs:{id:"_7-4-3-删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-3-删除"}},[a._v("#")]),a._v(" 7.4.3 删除")]),a._v(" "),_("ol",[_("li",[a._v("第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null。")]),a._v(" "),_("li",[a._v("第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的\n子节点就可以了。")]),a._v(" "),_("li",[a._v("第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。")])]),a._v(" "),_("h2",{attrs:{id:"八、图-graph"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#八、图-graph"}},[a._v("#")]),a._v(" 八、图(graph)")]),a._v(" "),_("ul",[_("li",[a._v("定义：G=(V,E)，其中V是顶点的有限集合，E是连接V中两个不同顶点(顶点对)的边的有限集合。")])]),a._v(" "),_("h3",{attrs:{id:"_8-1-邻接矩阵-adjacency-matrix"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-邻接矩阵-adjacency-matrix"}},[a._v("#")]),a._v(" 8.1 邻接矩阵(adjacency matrix)")]),a._v(" "),_("ul",[_("li",[a._v("定义：一种采用邻接矩阵数组表示顶点之间相邻关系的存储结构。")])]),a._v(" "),_("h3",{attrs:{id:"_8-2-邻接表-adjacency-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-邻接表-adjacency-list"}},[a._v("#")]),a._v(" 8.2 邻接表(adjacency list)")]),a._v(" "),_("ul",[_("li",[a._v("定义：一种顺序与链式存储相结合的存储方法。")])]),a._v(" "),_("h2",{attrs:{id:"九、集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#九、集合"}},[a._v("#")]),a._v(" 九、集合")]),a._v(" "),_("p",[a._v("待学习：https://juejin.im/post/583eaca2a22b9d006c243ccf")]),a._v(" "),_("h2",{attrs:{id:"其他"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[a._v("#")]),a._v(" 其他")]),a._v(" "),_("h3",{attrs:{id:"时间复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[a._v("#")]),a._v(" 时间复杂度")]),a._v(" "),_("p",[a._v("实际是指程序运行次数，而不是程序运行时间。")]),a._v(" "),_("p",[a._v("一般讨论的是最坏时间复杂度，最坏即上限。")]),a._v(" "),_("h4",{attrs:{id:"常用的时间复杂度-依次增加"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用的时间复杂度-依次增加"}},[a._v("#")]),a._v(" 常用的时间复杂度（依次增加）")]),a._v(" "),_("ol",[_("li",[a._v("常数型：O(1)")]),a._v(" "),_("li",[a._v("对数型：O(log2n)=O(log3n)=O(logn)")]),a._v(" "),_("li",[a._v("线性型：O(n)")]),a._v(" "),_("li",[a._v("二维型：O(nlog2n)=O(nlogn)")]),a._v(" "),_("li",[a._v("平方型：O(n^2)")]),a._v(" "),_("li",[a._v("立方型：O(n^3)")]),a._v(" "),_("li",[a._v("指数型：O(2^n)")])]),a._v(" "),_("h3",{attrs:{id:"空间复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[a._v("#")]),a._v(" 空间复杂度")]),a._v(" "),_("p",[a._v("实际是指计算整个算法的辅助空间单元的个数，即算法执行时创建的变量（包含临时变量）个数，而不是计算实际占用空间。")]),a._v(" "),_("p",[a._v("参考链接："),_("a",{attrs:{href:"https://blog.csdn.net/w_y_x_y/article/details/78733667",target:"_blank",rel:"noopener noreferrer"}},[a._v("分析时间复杂度&空间复杂度，以二分查找和斐波那契数的递归和非递归算法为例"),_("OutboundLink")],1)]),a._v(" "),_("h3",{attrs:{id:"稳定性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#稳定性"}},[a._v("#")]),a._v(" 稳定性")]),a._v(" "),_("p",[a._v("排序前后两个相等的数相对位置不变，则算法稳定。")]),a._v(" "),_("p",[a._v("**稳定性得好处：**从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。")]),a._v(" "),_("p",[_("strong",[a._v("各排序算法的稳定性：")])]),a._v(" "),_("p",[a._v("1、堆排序、快速排序、希尔排序、直接选择排序"),_("strong",[a._v("不是稳定")]),a._v("的排序算法；")]),a._v(" "),_("p",[a._v("2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序"),_("strong",[a._v("是稳定")]),a._v("的排序算法。")]),a._v(" "),_("p",[a._v("参考链接："),_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/36120420",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://zhuanlan.zhihu.com/p/36120420"),_("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);